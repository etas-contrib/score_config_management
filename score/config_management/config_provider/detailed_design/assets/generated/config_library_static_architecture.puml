@startuml

skinparam linetype ortho

skinparam package<<ConfigProvider>> {
    BorderColor #4682B4
}

skinparam package<<Persistency>> {
    BorderColor #CD5C5C
}

skinparam package<<InternalConfigProvider_proxy>> {
    BorderColor #DAA520
}


' Submodule: Logger
package mw::log <<frame>> {
class Logger {
}

}

' Submodule: ProxyNeedsFactory
package mw::service::factory <<frame>> {
class ProxyNeedsFactory<typename ProxyNeeds> <<template>>{
+ template<typename ...Strategy> Create<Strategy ...>(): ProxyNeeds
}
}

' Submodule: ProxyNeeds
package mw::service <<frame>> {
    class ProxyNeeds<typename... ProxySpec> <<template>> {
    }
}

' Submodule: AdaptiveImmediateInstantiationStrategy
package mw::service <<frame>> {
    class AdaptiveImmediateInstantiationStrategy<template <typename IProxy, \n\
    typename ProxyImpl, \n\
    typename AraProxy, \n\
    typename PortIdentifier = void>> {
    }
}

' Submodule: MemoryResource
class score::cpp::pmr::memory_resource{
+ score::cpp::pmr::get_default_resource() : score::cpp::pmr::memory_resource*
}

' Submodule: ConfigProviderFactory
class ConfigProviderFactory {
+ Create(\n\
token : score::cpp::stop_token,\n\
timeout : std::chrono::milliseconds,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
score::cpp::pmr::memory_resource* const memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token ,\n\
timeout : std::chrono::milliseconds ,\n\
memory_resource : score::cpp::pmr::memory_resource* const ,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
--
- logger_ : mw::log::Logger&
--
Responsibility: This class is responsible to create ConfigProvider class
}

package "ConfigProvider" <<ConfigProvider>> {
' Submodule: ConfigProvider
abstract class ConfigProvider {
+ {abstract} GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::optional<std::chrono::milliseconds>) : Result<std::shared_ptr<const ParameterSet>>
+ {abstract} OnChangedInitialQualifierState(callback : InitialQualifierStateNotifierCallbackType&&) : ResultBlank
+ {abstract} OnChangedParameterSet(\n\
set_name : const std::string&,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ {abstract} GetInitialQualifierState(timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
+ {abstract} WaitUntilConnected(\n\
timeout : const std::chrono::milliseconds,\n\
stop_token : const score::cpp::stop_token&) : bool
+ {abstract} CheckParameterSetUpdates() : ResultBlank
+ {abstract} GetCachedParameterSetsCount() : std::size_t
--
Responsibility: This class is repsonsible for providing ParameterSet's and InitialQualifierState
}

' Submodule: ConfigProviderImpl
class ConfigProviderImpl {
+ GetParameterSet(\n\
set_name : const score::cpp::string_view\n\
timeout : const std::optional<std::chrono::milliseconds>) : Result<std::shared_ptr<const ParameterSet>>
+ OnChangedInitialQualifierState(callback : InitialQualifierStateNotifierCallbackType&&) : ResultBlank
+ OnChangedParameterSet(\n\
set_name : const std::string&,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ GetInitialQualifierState(timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
+ CheckParameterSetUpdates() : ResultBlank
+ WaitUntilConnected(\n\
timeout : const std::chrono::milliseconds,\n\
stop_token : const score::cpp::stop_token&) : bool
+ GetCachedParameterSetsCount() : std::size_t
+ IsAwaitingProxyConnection() : bool
+ ConfigProviderImpl(\n\
internal_config_provider_future : mw::service::ProxyFuture<std::unique_ptr<IInternalConfigProvider>>,\n\
user_stop_token : score::cpp::stop_token,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
callback : IsAvailableNotificationCallback,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>)
--
- logger_ : mw::log::Logger&
- parameter_sets_ : ParameterMap
- initial_qualifier_state_ : InitialQualifierState
- memory_resource_ : score::cpp::pmr::memory_resource* const
- internal_config_provider_ : std::shared_ptr<IInternalConfigProvider>
- mutex_ : mutable std::mutex
- internal_config_provider_cv_ : concurrency::InterruptibleConditionalVariable
- persistency_ : score::cpp::pmr::unique_ptr<Persistency>
- client_handlers_ : ClientHandlersMap
- max_samples_limit_ : score::cpp::optional<std::size_t>
- polling_cycle_interval_ : score::cpp::optional<std::chrono::milliseconds>
- proxy_available_thread_ : score::cpp::optional<score::cpp::jthread>
- stop_callback_ : score::cpp::optional<score::cpp::stop_callback>
}

ConfigProvider <|-- ConfigProviderImpl
}

package "Persistency" <<Persistency>> {
' Submodule: PersistencyFactory
class PersistencyFactory {
+ Create(\n\
handle : const mw::core::Result<mw::per::SharedHandle<KeyValueStorageType>>&,\n\
memory_resource : score::cpp::pmr::memory_resource* const) : score::cpp::pmr::unique_ptr<Persistency>
--
- logger_ : mw::log::Logger&
--
Responsibility: This class is responsible to create Persistency class
}

' Submodule: Persistency
abstract class Persistency {
+ {abstract} ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ {abstract} CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>) : void
--
Responsibilities: This class is responsible for reading and writing the ParameterSet to persistent storage
}

' Submodule: PersistencyImpl
class PersistencyImpl {
+ PersistencyImpl(handle : score::cpp::pmr::unique_ptr<score::mw::storage::KeyValueStorage<KeyValueStorageType>>)
+ ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>) : void
--
- kvs_ : score::cpp::pmr::unique_ptr<score::mw::storage::KeyValueStorage<KeyValueStorageType>>
- logger_ : mw::log::Logger&
}

Persistency <|-- PersistencyImpl


' Submodule: PersistencyImpl
class PersistencyImpl {
+ ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>) : void
--
- logger_ : mw::log::Logger&
}

Persistency <|-right- PersistencyImpl
PersistencyFactory .down. Persistency
}

' Submodule: ParameterSet
class ParameterSet {
+ ParameterSet(json_writer : std::unique_ptr<json::IJsonWriter>)
+ GetParameterSetAsString() : Result<score::cpp::pmr::string>
+ Add(parameter_name : const score::cpp::string_view, parameter_value : json::Any&&) : ResultBlank
+ Update(parameters : json::Object&&) : ResultBlank
+ SetCalibratable(is_calibratable : const bool) : void
+ SetQualifier(qualifier : const score::platform::config_daemon::ParameterSetQualifier) : void
+ GetQualifier() : score::platform::config_daemon::ParameterSetQualifier
+ GetParameter(parameter_name : const score::cpp::string_view) : Result<json::Any>
--
- data_ : std::unordered_map<score::cpp::pmr::string, Parameter>
- json_writer_ : std::unique_ptr<json::IJsonWriter>
- qualifier_ : score::platform::config_daemon::ParameterSetQualifier
- is_calibratable_ : bool
--
Responsibility: This class encapsulates the idea of ParameterSet in detailed design
}
ParameterSet o-down- Parameter

' Submodule: ParameterSetQualifier
enum ParameterSetQualifier {
kUnqualified
kQualified
kDefault
kModified
}

' Submodule: ConfigProviderError
enum ConfigProviderError {
kParsingFailed
kObjectCastingError
kParameterNotFound
kValueCastingError
kValueNotFound
kProxyNotReady
kProxyAccessTimeout
kProxyReturnedNoResult
kEmptyCallbackProvided
kCallbackAlreadySet
kMethodNotSupported
kFailedToSubscribe
kParameterSetNotFound
}

package "InternalConfigProvider_proxy" <<InternalConfigProvider_proxy>> {
' Submodule: IInternalConfigProvider
abstract class IInternalConfigProvider {
+ {abstract} GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::chrono::milliseconds) : Result<json::Any>
+ {abstract} TrySubscribeToLastUpdatedParameterSetEvent(\n\
stop_token : const score::cpp::stop_token&,\n\
callback : OnChangedParameterSetCallback&&) : bool
+ {abstract} GetInitialQualifierState(timeout : const std::chrono::milliseconds) : InitialQualifierState
+ {abstract} StartParameterSetUpdatePollingRoutine(\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>) : void
+ {abstract} StopParameterSetUpdatePollingRoutine() : void
+ {abstract} CheckParameterSetUpdates() : void
--
Responsibilities: This class wraps communication with external service InternalConfigProvider
}

' Submodule: InternalConfigProvider
class InternalConfigProvider {
+ InternalConfigProvider(proxy : std::unique_ptr<AdaptiveProxy>)
+ GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::chrono::milliseconds) : Result<json::Any>
+ TrySubscribeToLastUpdatedParameterSetEvent(\n\
stop_token : const score::cpp::stop_token&,\n\
callback : OnChangedParameterSetCallback&&) : bool
+ GetInitialQualifierState(timeout : const std::chrono::milliseconds) : InitialQualifierState
+ StartParameterSetUpdatePollingRoutine(\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>) : void
+ StopParameterSetUpdatePollingRoutine() : void
+ CheckParameterSetUpdates() : void
--
- logger_ : mw::log::Logger&
- proxy_ : std::unique_ptr<AdaptiveProxy>
- on_changed_parameter_set_callback_ : OnChangedParameterSetCallback
- is_available_notification_callback_ : IsAvailableNotificationCallback
- max_samples_limit_ : std::size_t
- polling_cycle_interval_ : std::chrono::milliseconds
- polling_routine_cv_ : concurrency::InterruptibleConditionalVariable
- last_updated_parameter_set_names_ : score::cpp::pmr::unordered_set<std::string>
- mutex_ : mutable std::mutex
- polling_thread_ : score::cpp::optional<score::cpp::jthread>
}

IInternalConfigProvider <|-- InternalConfigProvider


class Proxies{
using Proxies = mw::service::ProxyNeeds<IInternalConfigProvider>
--
Responsibility: Owns a single instance of InternalConfigProvider proxy.
}
class InternalConfigProviderProxy <<generated>> #Gray{
Responsibility: This is the generated proxy from mw::com.
}
InternalConfigProvider o-- InternalConfigProviderProxy
Proxies o-- IInternalConfigProvider
}

Adaptive_Application *-- ConfigProvider.ConfigProvider
Adaptive_Application -left-> PersistencyFactory : construct
Adaptive_Application --> ConfigProviderFactory : construct
ConfigProviderImpl <-right- ConfigProviderFactory : construct
Persistency.Persistency --* ConfigProviderImpl
ParameterSet <-up- ConfigProviderImpl : creates & returns
ConfigProviderImpl ..> ConfigProviderError : create
ConfigProviderImpl *-- IInternalConfigProvider
ConfigProviderFactory -down-> Proxies : construct
ConfigProviderFactory -up-> ProxyNeedsFactory : use Strategy: InternalConfigProviderStrategy ProxyNeeds: mw::service::Optional<IInternalConfigProvider>
ConfigProviderFactory --> ProxyNeeds
ConfigProviderFactory --> AdaptiveImmediateInstantiationStrategy
ConfigProviderFactory --> score::cpp::pmr::memory_resource : Use
ParameterSet o-- ParameterSetQualifier
ParameterSet ..> ConfigProviderError
Logger <.up. ConfigProvider.ConfigProvider : Use

note right of ParameterSet #LightSkyBlue
    ConfigProviderImpl creates a ParameterSet as a business
    object abstraction for a specific user application.

    We use a shared_ptr, since the OnChange callback
    will need to capture the ParameterSet map.
end note

note left of InternalConfigProviderProxy #LightSkyBlue
    Following the Proxy-Pattern of mw::service
end note

@enduml
